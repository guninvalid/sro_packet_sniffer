from sniffing.packet_class import decrypt
import pytest

#largely generated by deepseek and fixed up

def all():
    test_decrypt_basic_functionality()
    test_decrypt_empty_data()
    test_decrypt_single_byte

def test_decrypt_basic_functionality():
    """Test basic decryption with simple inputs"""
    # Arrange
    data_bytes = b"\x6c\x6f\x6c"  # Encrypted "abc" with key "a"
    encryption_key = "a"
    expected_result = b"abc"
    
    # Act
    result = decrypt(data_bytes, encryption_key)
    
    # Assert
    assert result == expected_result

def test_decrypt_empty_data():
    """Test decryption with empty data bytes"""
    # Arrange
    data_bytes = b""
    encryption_key = "testkey"
    
    # Act
    result = decrypt(data_bytes, encryption_key)
    
    # Assert
    assert result == b""

def test_decrypt_single_byte():
    """Test decryption with single byte"""
    # Arrange
    data_bytes = b"\x65"  # 'a' + 'a' = 97 + 97 = 194 -> 194 - 97 = 97 -> 'a'
    encryption_key = "a"
    expected_result = b"a"
    
    # Act
    result = decrypt(data_bytes, encryption_key)
    
    # Assert
    assert result == expected_result

# def test_decrypt_key_longer_than_data():
#     """Test when key is longer than data"""
#     # Arrange
#     data_bytes = b"\x66\x67"  # "ab" encrypted with "key"
#     encryption_key = "verylongkey"
#     expected_result = b"ab"
    
#     # Act
#     result = decrypt(data_bytes, encryption_key)
    
#     # Assert
#     assert result == expected_result

# def test_decrypt_key_shorter_than_data():
#     """Test when key is shorter than data (wraps around)"""
#     # Arrange
#     data_bytes = b"\x66\x67\x68\x69"  # "abcd" encrypted with "ab"
#     encryption_key = "ab"
#     expected_result = b"abcd"
    
#     # Act
#     result = decrypt(data_bytes, encryption_key)
    
#     # Assert
#     assert result == expected_result

# def test_decrypt_with_negative_wraparound():
#     """Test decryption that requires negative wraparound"""
#     # Arrange
#     # Encrypted byte = 10, key byte = 20: 10 - 20 = -10 -> 246 after wraparound
#     data_bytes = b"\x0a"
#     encryption_key = "\x14"  # chr(20)
#     expected_result = b"\xf6"  # 246
    
#     # Act
#     result = decrypt(data_bytes, encryption_key)
    
#     # Assert
#     assert result == expected_result

# # def test_decrypt_unicode_key():
# #     """Test decryption with unicode characters in key"""
# #     # Arrange
# #     data_bytes = b"\xa2\xa3"  # Encrypted with "ðŸ”‘"
# #     encryption_key = "ðŸ”‘"
# #     # Key bytes for "ðŸ”‘" are [240, 159, 148, 145]
    
# #     # Act
# #     result = decrypt(data_bytes, encryption_key)
    
# #     # Assert
# #     # Just verify it doesn't crash and returns correct length
# #     assert len(result) == len(data_bytes)

# # def test_decrypt_special_characters_key():
# #     """Test decryption with special characters in key"""
# #     # Arrange
# #     data_bytes = b"\x25\x26\x27"
# #     encryption_key = "!@#"
    
# #     # Act
# #     result = decrypt(data_bytes, encryption_key)
    
# #     # Assert
# #     assert len(result) == len(data_bytes)

# # def test_decrypt_known_values():
# #     """Test with known input/output pairs"""
# #     # Test case 1: Simple text
# #     data1 = b"hello".encode()  # Already encrypted form
# #     key1 = "secret"
# #     result1 = decrypt(data1, key1)
# #     assert len(result1) == len(data1)
    
# #     # Test case 2: Binary data
# #     data2 = bytes([255, 0, 128, 64])
# #     key2 = "key"
# #     result2 = decrypt(data2, key2)
# #     assert len(result2) == len(data2)

# # def test_decrypt_reversibility():
# #     """Test that decryption reverses a hypothetical encryption"""
# #     # This assumes the encryption would be: byte + key_byte
# #     original_data = b"test data for reversibility"
# #     key = "encryptionkey"
    
# #     # Simulate encryption (reverse of decryption logic)
# #     encrypted_data = bytearray()
# #     key_bytes = key.encode('utf-8')
# #     key_length = len(key_bytes)
    
# #     for i, byte in enumerate(original_data):
# #         offset = key_bytes[i % key_length]
# #         encrypted_byte = (byte + offset) % 256
# #         encrypted_data.append(encrypted_byte)
    
# #     encrypted_bytes = bytes(encrypted_data)
    
# #     # Now decrypt should return original data
# #     result = decrypt(encrypted_bytes, key)
    
# #     # Assert
# #     assert result == original_data

# def test_decrypt_boundary_values():
#     """Test decryption with boundary byte values"""
#     # Arrange
#     data_bytes = bytes([0, 255, 128])  # Min, max, and middle values
#     encryption_key = "test"
    
#     # Act
#     result = decrypt(data_bytes, encryption_key)
    
#     # Assert
#     assert len(result) == 3
#     # All bytes should be valid (0-255)
#     assert all(0 <= b <= 255 for b in result)

# def test_decrypt_large_data():
#     """Test decryption with large data set"""
#     # Arrange
#     data_bytes = b"x" * 10000  # 10KB of data
#     encryption_key = "key"
    
#     # Act
#     result = decrypt(data_bytes, encryption_key)
    
#     # Assert
#     assert len(result) == len(data_bytes)

# def test_decrypt_very_long_key():
#     """Test decryption with very long key"""
#     # Arrange
#     data_bytes = b"short"
#     encryption_key = "a" * 1000  # Very long key
    
#     # Act
#     result = decrypt(data_bytes, encryption_key)
    
#     # Assert
#     assert len(result) == len(data_bytes)

# # @patch('your_module.debug')  # Replace with actual module name
# # def test_decrypt_calls_debug(self, mock_debug):
# #     """Test that debug function is called"""
# #     # Arrange
# #     data_bytes = b"test"
# #     encryption_key = "key"
    
# #     # Act
# #     decrypt(data_bytes, encryption_key)
    
# #     # Assert
# #     mock_debug.assert_called_once_with("Decrypyting!")

# def test_decrypt_identity_with_zero_key():
#     """Test that key of null bytes returns original data"""
#     # Arrange
#     data_bytes = b"\x01\x02\x03\xff"
#     encryption_key = "\x00"  # Null byte
    
#     # Act
#     result = decrypt(data_bytes, encryption_key)
    
#     # Assert
#     assert result == data_bytes

# def test_decrypt_consistent_with_repeated_key():
#     """Test that key repetition works correctly"""
#     # Arrange
#     data_bytes = b"\x68\x69\x6a\x6b"  # "abcd" encrypted with "a"
#     encryption_key = "a"
#     expected_result = b"abcd"
    
#     # Act
#     result = decrypt(data_bytes, encryption_key)
    
#     # Assert
#     assert result == expected_result

# def test_decrypt_mixed_bytes():
#     """Test decryption with mixed byte values"""
#     # Arrange
#     data_bytes = bytes(range(256))  # All possible byte values
#     encryption_key = "mixed"
    
#     # Act
#     result = decrypt(data_bytes, encryption_key)
    
#     # Assert
#     assert len(result) == 256
#     assert all(0 <= b <= 255 for b in result)

# def test_decrypt_verify_calculation():
#     """Verify the exact calculation for a specific case"""
#     # Let's manually calculate one byte:
#     # data_byte = 150, key_byte = 100
#     # final_byte = 150 - 100 = 50
#     data_bytes = b"\x96"  # 150
#     encryption_key = "d"  # 'd' = 100 in ASCII
    
#     result = decrypt(data_bytes, encryption_key)
    
#     assert result == b"2"  # ASCII 50 = '2'